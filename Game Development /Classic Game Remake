import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Play, Pause, RotateCcw, Trophy, Zap } from 'lucide-react';

export default function SnakeGame() {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('menu'); // menu, playing, paused, gameOver
  const [score, setScore] = useState(0);
  const [highScore, setHighScore] = useState(0);
  const [speed, setSpeed] = useState(150);
  const [difficulty, setDifficulty] = useState('medium');
  
  const gridSize = 20;
  const tileSize = 25;
  
  const gameRef = useRef({
    snake: [{ x: 10, y: 10 }],
    direction: { x: 1, y: 0 },
    nextDirection: { x: 1, y: 0 },
    food: { x: 15, y: 15 },
    obstacles: []
  });

  useEffect(() => {
    loadHighScore();
  }, []);

  const loadHighScore = async () => {
    try {
      const result = await window.storage.get('snake-highscore');
      if (result) {
        setHighScore(parseInt(result.value));
      }
    } catch (error) {
      console.log('No high score found');
    }
  };

  const saveHighScore = async (score) => {
    try {
      await window.storage.set('snake-highscore', score.toString());
    } catch (error) {
      console.error('Error saving high score:', error);
    }
  };

  const generateFood = useCallback(() => {
    const { snake, obstacles } = gameRef.current;
    let newFood;
    let isValid = false;
    
    while (!isValid) {
      newFood = {
        x: Math.floor(Math.random() * gridSize),
        y: Math.floor(Math.random() * gridSize)
      };
      
      isValid = !snake.some(segment => segment.x === newFood.x && segment.y === newFood.y) &&
                !obstacles.some(obs => obs.x === newFood.x && obs.y === newFood.y);
    }
    
    return newFood;
  }, []);

  const generateObstacles = useCallback(() => {
    const obstacles = [];
    const count = difficulty === 'easy' ? 0 : difficulty === 'medium' ? 5 : 10;
    
    for (let i = 0; i < count; i++) {
      obstacles.push({
        x: Math.floor(Math.random() * gridSize),
        y: Math.floor(Math.random() * gridSize)
      });
    }
    
    return obstacles;
  }, [difficulty]);

  const startGame = useCallback(() => {
    gameRef.current = {
      snake: [{ x: 10, y: 10 }],
      direction: { x: 1, y: 0 },
      nextDirection: { x: 1, y: 0 },
      food: { x: 15, y: 15 },
      obstacles: generateObstacles()
    };
    
    gameRef.current.food = generateFood();
    setScore(0);
    setGameState('playing');
    
    const speedMap = { easy: 200, medium: 150, hard: 100 };
    setSpeed(speedMap[difficulty]);
  }, [difficulty, generateFood, generateObstacles]);

  const resetGame = useCallback(() => {
    setGameState('menu');
    setScore(0);
  }, []);

  const checkCollision = useCallback((head) => {
    const { snake, obstacles } = gameRef.current;
    
    // Wall collision
    if (head.x < 0 || head.x >= gridSize || head.y < 0 || head.y >= gridSize) {
      return true;
    }
    
    // Self collision
    if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
      return true;
    }
    
    // Obstacle collision
    if (obstacles.some(obs => obs.x === head.x && obs.y === head.y)) {
      return true;
    }
    
    return false;
  }, []);

  const gameLoop = useCallback(() => {
    if (gameState !== 'playing') return;
    
    const game = gameRef.current;
    game.direction = game.nextDirection;
    
    const head = {
      x: game.snake[0].x + game.direction.x,
      y: game.snake[0].y + game.direction.y
    };
    
    if (checkCollision(head)) {
      setGameState('gameOver');
      if (score > highScore) {
        setHighScore(score);
        saveHighScore(score);
      }
      return;
    }
    
    game.snake.unshift(head);
    
    // Check if food is eaten
    if (head.x === game.food.x && head.y === game.food.y) {
      setScore(prev => prev + 10);
      game.food = generateFood();
    } else {
      game.snake.pop();
    }
    
    draw();
  }, [gameState, score, highScore, checkCollision, generateFood]);

  useEffect(() => {
    if (gameState === 'playing') {
      const interval = setInterval(gameLoop, speed);
      return () => clearInterval(interval);
    }
  }, [gameState, speed, gameLoop]);

  const draw = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const game = gameRef.current;
    
    // Clear canvas
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw grid
    ctx.strokeStyle = '#16213e';
    ctx.lineWidth = 1;
    for (let i = 0; i <= gridSize; i++) {
      ctx.beginPath();
      ctx.moveTo(i * tileSize, 0);
      ctx.lineTo(i * tileSize, canvas.height);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(0, i * tileSize);
      ctx.lineTo(canvas.width, i * tileSize);
      ctx.stroke();
    }
    
    // Draw obstacles
    ctx.fillStyle = '#e94560';
    game.obstacles.forEach(obs => {
      ctx.fillRect(obs.x * tileSize + 2, obs.y * tileSize + 2, tileSize - 4, tileSize - 4);
    });
    
    // Draw food with glow
    const foodGradient = ctx.createRadialGradient(
      game.food.x * tileSize + tileSize / 2,
      game.food.y * tileSize + tileSize / 2,
      0,
      game.food.x * tileSize + tileSize / 2,
      game.food.y * tileSize + tileSize / 2,
      tileSize
    );
    foodGradient.addColorStop(0, '#ffd700');
    foodGradient.addColorStop(1, '#ff6b35');
    ctx.fillStyle = foodGradient;
    ctx.beginPath();
    ctx.arc(
      game.food.x * tileSize + tileSize / 2,
      game.food.y * tileSize + tileSize / 2,
      tileSize / 2 - 3,
      0,
      Math.PI * 2
    );
    ctx.fill();
    
    // Draw snake with gradient
    game.snake.forEach((segment, index) => {
      const opacity = 1 - (index / game.snake.length) * 0.5;
      const hue = 120 + (index / game.snake.length) * 60;
      ctx.fillStyle = `hsla(${hue}, 70%, 50%, ${opacity})`;
      
      if (index === 0) {
        // Snake head
        ctx.fillStyle = '#00ff88';
        ctx.fillRect(segment.x * tileSize + 1, segment.y * tileSize + 1, tileSize - 2, tileSize - 2);
        
        // Eyes
        ctx.fillStyle = '#1a1a2e';
        const eyeSize = 3;
        const eyeOffset = tileSize / 3;
        ctx.fillRect(segment.x * tileSize + eyeOffset - eyeSize/2, segment.y * tileSize + eyeOffset - eyeSize/2, eyeSize, eyeSize);
        ctx.fillRect(segment.x * tileSize + tileSize - eyeOffset - eyeSize/2, segment.y * tileSize + eyeOffset - eyeSize/2, eyeSize, eyeSize);
      } else {
        ctx.fillRect(segment.x * tileSize + 1, segment.y * tileSize + 1, tileSize - 2, tileSize - 2);
      }
    });
  };

  useEffect(() => {
    if (gameState === 'playing' || gameState === 'paused') {
      draw();
    }
  }, [gameState]);

  const handleKeyPress = useCallback((e) => {
    if (gameState !== 'playing') return;
    
    const game = gameRef.current;
    const key = e.key;
    
    if ((key === 'ArrowUp' || key === 'w') && game.direction.y === 0) {
      game.nextDirection = { x: 0, y: -1 };
    } else if ((key === 'ArrowDown' || key === 's') && game.direction.y === 0) {
      game.nextDirection = { x: 0, y: 1 };
    } else if ((key === 'ArrowLeft' || key === 'a') && game.direction.x === 0) {
      game.nextDirection = { x: -1, y: 0 };
    } else if ((key === 'ArrowRight' || key === 'd') && game.direction.x === 0) {
      game.nextDirection = { x: 1, y: 0 };
    } else if (key === ' ' || key === 'Escape') {
      setGameState(gameState === 'playing' ? 'paused' : 'playing');
    }
  }, [gameState]);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [handleKeyPress]);

  const togglePause = () => {
    setGameState(gameState === 'playing' ? 'paused' : 'playing');
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900 flex items-center justify-center p-4">
      <div className="max-w-4xl w-full">
        {/* Header */}
        <div className="text-center mb-6">
          <h1 className="text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-blue-500 mb-2">
            SNAKE
          </h1>
          <p className="text-purple-300">Classic arcade action reimagined</p>
        </div>

        {/* Score Board */}
        <div className="flex justify-between items-center mb-4 bg-white/10 backdrop-blur-lg rounded-xl p-4 border border-white/20">
          <div className="flex items-center gap-2">
            <Zap className="text-yellow-400" size={24} />
            <div>
              <div className="text-sm text-purple-300">Score</div>
              <div className="text-2xl font-bold text-white">{score}</div>
            </div>
          </div>
          <div className="flex items-center gap-2">
            <Trophy className="text-yellow-400" size={24} />
            <div>
              <div className="text-sm text-purple-300">High Score</div>
              <div className="text-2xl font-bold text-white">{highScore}</div>
            </div>
          </div>
        </div>

        {/* Game Canvas Container */}
        <div className="relative bg-white/10 backdrop-blur-lg rounded-xl p-4 border border-white/20">
          <canvas
            ref={canvasRef}
            width={gridSize * tileSize}
            height={gridSize * tileSize}
            className="mx-auto rounded-lg shadow-2xl"
          />

          {/* Menu Overlay */}
          {gameState === 'menu' && (
            <div className="absolute inset-0 flex items-center justify-center bg-black/80 rounded-xl">
              <div className="text-center space-y-6 p-8">
                <h2 className="text-4xl font-bold text-white mb-8">Ready to Play?</h2>
                
                <div className="space-y-3">
                  <label className="block text-white text-lg mb-2">Select Difficulty</label>
                  <div className="flex gap-3 justify-center">
                    {['easy', 'medium', 'hard'].map(level => (
                      <button
                        key={level}
                        onClick={() => setDifficulty(level)}
                        className={`px-6 py-3 rounded-lg font-semibold capitalize transition-all ${
                          difficulty === level
                            ? 'bg-green-500 text-white scale-110'
                            : 'bg-white/20 text-purple-200 hover:bg-white/30'
                        }`}
                      >
                        {level}
                      </button>
                    ))}
                  </div>
                </div>

                <button
                  onClick={startGame}
                  className="px-8 py-4 bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white rounded-lg font-bold text-xl flex items-center gap-2 mx-auto transition-all transform hover:scale-105"
                >
                  <Play size={24} />
                  Start Game
                </button>

                <div className="text-purple-300 text-sm mt-8">
                  <p>Use Arrow Keys or WASD to move</p>
                  <p>Press Space or Escape to pause</p>
                </div>
              </div>
            </div>
          )}

          {/* Paused Overlay */}
          {gameState === 'paused' && (
            <div className="absolute inset-0 flex items-center justify-center bg-black/80 rounded-xl">
              <div className="text-center space-y-6">
                <h2 className="text-4xl font-bold text-white">PAUSED</h2>
                <button
                  onClick={togglePause}
                  className="px-8 py-4 bg-green-500 hover:bg-green-600 text-white rounded-lg font-bold text-xl flex items-center gap-2 mx-auto"
                >
                  <Play size={24} />
                  Resume
                </button>
                <button
                  onClick={resetGame}
                  className="px-6 py-3 bg-red-500 hover:bg-red-600 text-white rounded-lg font-semibold flex items-center gap-2 mx-auto"
                >
                  <RotateCcw size={20} />
                  Main Menu
                </button>
              </div>
            </div>
          )}

          {/* Game Over Overlay */}
          {gameState === 'gameOver' && (
            <div className="absolute inset-0 flex items-center justify-center bg-black/90 rounded-xl">
              <div className="text-center space-y-6">
                <h2 className="text-5xl font-bold text-red-500 mb-4">GAME OVER</h2>
                <div className="text-3xl text-white">
                  Score: <span className="text-yellow-400 font-bold">{score}</span>
                </div>
                {score > highScore && (
                  <div className="text-2xl text-green-400 animate-pulse">
                    ðŸŽ‰ New High Score! ðŸŽ‰
                  </div>
                )}
                <div className="flex gap-4 justify-center mt-8">
                  <button
                    onClick={startGame}
                    className="px-8 py-4 bg-green-500 hover:bg-green-600 text-white rounded-lg font-bold text-xl flex items-center gap-2"
                  >
                    <Play size={24} />
                    Play Again
                  </button>
                  <button
                    onClick={resetGame}
                    className="px-6 py-4 bg-purple-500 hover:bg-purple-600 text-white rounded-lg font-semibold flex items-center gap-2"
                  >
                    <RotateCcw size={20} />
                    Main Menu
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>

        {/* Controls Info */}
        {gameState === 'playing' && (
          <div className="mt-4 text-center">
            <button
              onClick={togglePause}
              className="px-6 py-2 bg-white/10 hover:bg-white/20 text-white rounded-lg font-semibold flex items-center gap-2 mx-auto border border-white/20"
            >
              <Pause size={20} />
              Pause (Space)
            </button>
          </div>
        )}
      </div>
    </div>
  );
}
